[{"categories":null,"content":"Notes ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:0","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Godot Signals Signals are Godot’s implementation of the observer pattern Use signal signal_name(param1, param2) to declare Emit with emit_signal(\"signal_name\", arg1, arg2) Connect with object.connect(\"signal_name\", self, \"_on_signal_received\") Super useful for decoupling game systems (e.g., player health changes triggering UI updates) ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:1","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"A* Pathfinding Started implementing A* for enemy AI Key insight: the heuristic function matters a lot for performance Using Manhattan distance for grid-based movement (no diagonals) Need to cache paths and only recalculate when player moves significantly Found a great visualization tool: pathfinding.js ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:2","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Go Interfaces Interfaces in Go are implicit - no need to declare implementation Any type that implements all methods automatically satisfies the interface Keep interfaces small (often just 1-2 methods) “Accept interfaces, return structs” is a common pattern The empty interface interface{} accepts any type (like any in newer Go versions) ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:3","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Random Discovered itch.io’s devlog feature - might cross-post there Need to set up a better note-taking workflow (currently using Obsidian + manual conversion) Read an interesting article about roguelike design patterns ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:4","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Tomorrow Implement basic A* pathfinding for enemies Refactor player movement to use signals Write up a proper blog post about dungeon generation ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:5","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":["Engineering","AI/ML"],"content":"Deploying Large Language Models (LLMs) effectively requires a robust architecture that can handle high concurrency, manage GPU resources efficiently, and scale dynamically. In this post, I’ll walk through a production-ready setup for hosting open-source models (like Llama 3 or Mistral) on AWS using Ray Serve for orchestration and FastAPI as the interface. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:0:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"The Architecture The stack consists of: Infrastructure: AWS EC2 instances (g5.xlarge or similar GPU-optimized instances) Orchestration: Ray Cluster (Head node + Worker nodes) Serving: Ray Serve wrapping a FastAPI application Model Engine: vLLM for high-throughput inference ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:1:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"Why Ray Serve? Ray Serve excels at “model composition” and scaling. Unlike simple Docker containers, Ray allows us to: Scale independently: Scale the model replicas separately from the API handling logic. Batching: Native support for dynamic request batching to maximize GPU utilization. Pipeline composition: Easily chain multiple models or pre/post-processing steps. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:1:1","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"Configuration Here is a simplified serve_config.yaml to get started. This configuration defines a deployment that autoscales based on request load. proxy_location: EveryNode http_options: host: 0.0.0.0 port: 8000 applications: - name: llm_app route_prefix: / import_path: app:deployment runtime_env: pip: - vllm - fastapi deployments: - name: VLLMDeployment autoscaling_config: min_replicas: 1 max_replicas: 4 target_num_ongoing_requests_per_replica: 10 ray_actor_options: num_gpus: 1\r","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:2:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"The FastAPI Wrapper We wrap the vLLM engine in a FastAPI app to expose standard REST endpoints. This allows easy integration with existing frontend applications or services. from fastapi import FastAPI from ray import serve from vllm import AsyncLLMEngine, SamplingParams app = FastAPI() @serve.deployment(num_gpus=1) @serve.ingress(app) class VLLMDeployment: def __init__(self): # Initialize vLLM engine self.engine = AsyncLLMEngine.from_engine_args(...) @app.post(\"/generate\") async def generate(self, prompt: str): sampling_params = SamplingParams(temperature=0.7, max_tokens=100) results = await self.engine.generate(prompt, sampling_params, ...) return {\"text\": results[0].outputs[0].text} deployment = VLLMDeployment.bind()\r","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:3:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"Deployment on AWS Cluster Setup: Use the Ray Cluster Launcher to provision EC2 instances. Define your cluster configuration in a cluster.yaml file, specifying the instance types (e.g., g5.xlarge for workers). Deploy: Run ray up cluster.yaml to start the cluster. Serve: Submit your serve application using serve run serve_config.yaml. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:4:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Engineering","AI/ML"],"content":"Monitoring and Optimization Ray provides a built-in dashboard to monitor actor status, GPU usage, and request latency. For production, integrate this with Prometheus and Grafana to track: Queue Latency: Time requests spend waiting for a replica. GPU Utilization: Ensure you aren’t under-provisioning expensive hardware. Token Throughput: Measure tokens/second to benchmark performance. By leveraging Ray Serve with AWS, we create a flexible, scalable inference platform that avoids the vendor lock-in of managed services while providing full control over the serving infrastructure. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:5:0","tags":["aws","llm","ray-serve","fastapi","devops","python"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":["Game Development"],"content":"Context I’ve been wanting to build a complete game from scratch for a while now. After exploring different genres, I settled on a roguelike because: Procedural generation is fascinating to me The scope is manageable for a solo dev There’s a great community and lots of resources I’m using Godot 4.2 because it’s lightweight, open-source, and has excellent 2D support. ","date":"2025-11-20","objectID":"/blog/first-devlog/:1:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"What I did This week I focused on getting the basic foundation in place: Set up the Godot project structure Implemented a simple grid-based movement system Created a basic dungeon generator using BSP (Binary Space Partitioning) Added collision detection for walls and obstacles Set up a camera that follows the player The dungeon generator was the most challenging part. I followed a tutorial initially but had to adapt it significantly to work with Godot 4’s new architecture. ","date":"2025-11-20","objectID":"/blog/first-devlog/:2:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"What I learned Godot’s tilemap system is powerful but has a learning curve. I spent a few hours debugging why my collisions weren’t working, only to realize I hadn’t set up the physics layers correctly. Procedural generation requires careful seeding. I want players to be able to share seeds for interesting dungeons, so I had to ensure my random number generation was deterministic. Start simple, iterate often. My first dungeon generator created boring rectangular rooms. Instead of trying to make it perfect immediately, I got something working and then improved it incrementally. ","date":"2025-11-20","objectID":"/blog/first-devlog/:3:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"Next steps Add basic combat mechanics (attack, health, damage) Implement enemy AI (simple chase behavior) Create an inventory system Add item pickups (health potions, weapons) Design a few enemy types with different behaviors I’m aiming to have a playable prototype with combat by the end of next week. Follow along for more updates! ","date":"2025-11-20","objectID":"/blog/first-devlog/:4:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"}]