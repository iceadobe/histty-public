[{"categories":null,"content":"Overview A comprehensive guide documenting the challenges, workarounds, and best practices for running Windows on ARM-based devices (such as Surface Pro X, Snapdragon-powered laptops, or Apple Silicon with Parallels). ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:1:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Problem Windows on ARM architecture presents unique challenges: x86/x64 emulation overhead causing performance degradation Application compatibility - many developer tools lack native ARM64 builds Driver limitations for peripherals and specialized hardware Development toolchain issues with certain build systems and compilers Battery life inconsistencies when running emulated applications ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:2:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Common Pitfalls ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:3:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"1. Application Compatibility Docker Desktop requires special ARM builds or doesn’t work at all Some IDEs and editors have poor ARM64 support Legacy enterprise software often fails to run Browser extensions and plugins may have issues ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:3:1","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"2. Development Toolchains Native compilers may not support ARM64 targets Cross-compilation setups become necessary Build times can be unpredictable with emulation Package managers sometimes lack ARM-compatible packages ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:3:2","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"3. Performance Issues x64 emulation adds 20-40% performance penalty Memory usage increases under emulation Thermal throttling during intensive tasks GPU acceleration limitations ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:3:3","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"4. Driver and Hardware Support Limited driver availability for specialized peripherals Some USB devices may not work properly External GPU support is often unavailable Fingerprint readers and biometric devices can be problematic ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:3:4","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Solution Mitigation strategies and workarounds: ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:4:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Use Native ARM64 Applications When Possible Windows Terminal, VS Code, Edge browser all have native builds Prefer web-based tools and cloud IDEs Check for ARM64 installers before defaulting to x64 ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:4:1","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Virtual Machine Strategy Run x64 Windows VM for incompatible tools Use cloud development environments (GitHub Codespaces, AWS Cloud9) WSL2 for Linux development workflows ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:4:2","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Development Environment Alternatives Remote development via SSH Container-based development with compatible runtimes Cross-compilation configurations ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:4:3","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Testing and Validation Always test on actual ARM hardware before committing Maintain compatibility matrices for tools and dependencies Document emulation requirements for team members ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:4:4","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Architecture / Stack OS: Windows 11 ARM64 Emulation: Microsoft x64 emulation layer Development: ARM64 native tools where available Fallback: Cloud-based development environments Testing: Multi-architecture CI/CD pipelines ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:5:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"What I Learned ARM architecture is the future, but Windows ecosystem is still catching up Native ARM64 application performance is excellent when available Cloud development can mitigate many compatibility issues Battery life improvements with native ARM apps are significant Documentation and community support are crucial for edge cases ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:6:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Recommendations ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:7:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"For Developers Check compatibility before purchasing ARM devices Maintain fallback development environments Contribute to ARM64 support in open-source projects ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:7:1","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"For Teams Document ARM compatibility requirements Provide cloud development alternatives Test on multiple architectures in CI/CD ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:7:2","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Resources Windows ARM Developer Documentation ARM64 Application List Community forums and compatibility databases ","date":"2025-11-27","objectID":"/projects/windows-on-arm-pitfalls/:8:0","tags":["windows","config"],"title":"Windows on Arm Pitfalls","uri":"/projects/windows-on-arm-pitfalls/"},{"categories":null,"content":"Overview A complete dotfile management solution using chezmoi that enables seamless configuration synchronization across multiple machines and operating systems. Supports templating for machine-specific configurations, encrypted secrets, and one-command environment setup. ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:1:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Problem Managing configuration files across multiple machines is challenging: Manual synchronization is error-prone and time-consuming Platform differences (Windows/Linux/macOS) require different configurations Secrets management in dotfiles poses security risks Machine-specific settings make simple Git repos inadequate Setup time for new machines is lengthy and tedious ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:2:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Solution chezmoi provides a declarative approach to dotfile management: Version-controlled configurations with Git Template-based configs for cross-platform compatibility Encrypted secret storage Machine-specific customizations Idempotent apply operations One-command bootstrap process ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:3:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Key Features ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:4:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Cross-Platform Support Automatically detects OS and architecture Platform-specific templates (.tmpl files) Conditional includes based on system properties Path handling for Windows vs Unix systems ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:4:1","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Template System Go template syntax for dynamic configurations Variables for hostname, OS, architecture Custom data files for per-machine settings Conditional logic for environment-specific configs ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:4:2","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Secret Management Encrypted files using age or gpg Secure password manager integration Environment variable substitution Automatic decryption on apply ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:4:3","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"State Management Tracks what files are managed Detects external modifications Interactive merge for conflicts Rollback capabilities ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:4:4","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Architecture / Stack Core Tool: chezmoi (written in Go) Configuration Structure: ~/.local/share/chezmoi/ ├── .chezmoi.toml.tmpl # Main config with machine data ├── dot_gitconfig.tmpl # Git configuration ├── dot_config/ │ ├── nvim/ │ │ └── init.lua │ ├── powershell/ │ │ └── profile.ps1.tmpl │ └── starship.toml ├── private_dot_ssh/ │ └── encrypted_config # Encrypted SSH config └── run_once_install-packages.sh.tmpl Managed Configurations: Shell configs (bash, zsh, PowerShell) Editor settings (Neovim, VS Code) Terminal emulator configs Git configuration SSH keys and config Development tool configs (Node, Python, Go) ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:5:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Implementation Details ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:6:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Template Examples OS-specific paths: {{- if eq .chezmoi.os \"windows\" }} set-alias vim \"C:\\\\Program Files\\\\Neovim\\\\bin\\\\nvim.exe\" {{- else }} alias vim=nvim {{- end }} Machine-specific configs: [user] name = {{ .name | quote }} email = {{ .email | quote }} {{- if .work }} signingkey = {{ .work_gpg_key }} {{- end }} ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:6:1","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Bootstrap Process One-line install: sh -c \"$(curl -fsLS get.chezmoi.io)\" -- init --apply \u003cgithub-username\u003e Machine-specific data collected interactively Templates applied based on OS/architecture Secrets decrypted with password/key Scripts executed for package installation Configurations symlinked to home directory ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:6:2","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"What I Learned Templating is powerful: Go templates handle complex conditional logic elegantly Secrets should stay encrypted: Never commit plaintext secrets, even in private repos Idempotency matters: Configurations should be reapplied safely without side effects Documentation is crucial: Future you won’t remember the template syntax Start simple: Begin with a few critical configs and expand gradually Test on fresh systems: Bootstrap process should work on clean machines ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:7:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Benefits Realized Setup time: New machine from bare to fully configured in \u003c 15 minutes Consistency: Identical configurations across work laptop, personal desktop, and cloud VMs Security: SSH keys and API tokens never exposed in Git history Maintenance: Single source of truth for all configurations Experimentation: Easy to test config changes and rollback ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:8:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Future Enhancements Integration with cloud secret managers (1Password, Bitwarden) Automated configuration testing in containers Machine role profiles (work, personal, server) Configuration generation from UI Team-shared base configurations ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:9:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Resources chezmoi Documentation My dotfiles repository Template reference guide ","date":"2025-11-26","objectID":"/projects/dotfiles-using-chezmoi/:10:0","tags":["config","dotfiles"],"title":"Cross-platform dotfiles using chezmoi","uri":"/projects/dotfiles-using-chezmoi/"},{"categories":null,"content":"Notes ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:0","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"Godot Signals Signals are Godot’s implementation of the observer pattern Use signal signal_name(param1, param2) to declare Emit with emit_signal(\"signal_name\", arg1, arg2) Connect with object.connect(\"signal_name\", self, \"_on_signal_received\") Super useful for decoupling game systems (e.g., player health changes triggering UI updates) ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:1","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"AI Pathfinding Started implementing AI for enemy AI Key insight: the heuristic function matters a lot for performance Using Manhattan distance for grid-based movement (no diagonals) Need to cache paths and only recalculate when player moves significantly Found a great visualization tool: pathfinding.js ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:2","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"Go Interfaces Interfaces in Go are implicit - no need to declare implementation Any type that implements all methods automatically satisfies the interface Keep interfaces small (often just 1-2 methods) “Accept interfaces, return structs” is a common pattern The empty interface interface{} accepts any type (like any in newer Go versions) ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:3","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"Random Discovered itch.io’s devlog feature - might cross-post there Need to set up a better note-taking workflow (currently using Obsidian + manual conversion) Read an interesting article about roguelike design patterns ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:4","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"Tomorrow Implement basic AI pathfinding for enemies Refactor player movement to use signals Write up a proper blog post about system design ","date":"2025-11-26","objectID":"/logs/2025/11/2025-11-26/:1:5","tags":["logs/2025-11"],"title":"November 26, 2025 — [Game] AI pathfinding and Godot signals","uri":"/logs/2025/11/2025-11-26/"},{"categories":null,"content":"Overview A comprehensive Windows productivity setup tailored for software developers, combining modern tiling window management, keyboard-driven workflows, and cross-platform dotfile management. ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:1:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Problem Default Windows productivity tools are often mouse-heavy and inefficient for developers who prefer keyboard-centric workflows. Managing configurations across multiple machines and environments is tedious without proper automation. ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:2:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Solution An integrated stack that provides: Tiling window management with Komorebi for efficient screen real estate usage Keyboard remapping via Kmonad for ergonomic shortcuts and custom layouts Dotfile management using chezmoi for version-controlled, reproducible configurations Development environment with Git and Neovim properly configured ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:3:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Key Features Automated window tiling and workspace management Custom keyboard layouts and shortcuts Cross-machine configuration synchronization Git integration with SSH key management Neovim setup with LSP and plugin management PowerShell and terminal configurations ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:4:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Setup Components ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:5:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Window Management (Komorebi) Automatic window tiling Workspace switching Custom layouts and rules ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:5:1","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Keyboard Configuration (Kmonad) Caps Lock as Control/Escape Custom navigation layers Application-specific shortcuts ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:5:2","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Dotfile Management (chezmoi) Template-based configurations Machine-specific adaptations Secret management One-command bootstrap process ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:5:3","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"What I Learned Building a cohesive productivity environment requires careful integration between tools Keyboard-driven workflows significantly improve development speed once mastered Dotfile automation is essential for maintaining consistency across machines Windows can be as developer-friendly as Linux with proper tooling ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:6:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Future Improvements Integration with WSL2 for Linux workflows Custom AutoHotkey scripts for advanced automation Cloud sync for workspace states Documentation site with setup guides ","date":"2025-11-26","objectID":"/projects/windows-productivity-setup/:7:0","tags":["config","dotfiles"],"title":"Windows Productivity Setup","uri":"/projects/windows-productivity-setup/"},{"categories":null,"content":"Deploying Large Language Models (LLMs) effectively requires a robust architecture that can handle high concurrency, manage GPU resources efficiently, and scale dynamically. In this post, I’ll walk through a production-ready setup for hosting open-source models (like Llama 3 or Mistral) on AWS using Ray Serve for orchestration and FastAPI as the interface. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:0:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"The Architecture The stack consists of: Infrastructure: AWS EC2 instances (g5.xlarge or similar GPU-optimized instances) Orchestration: Ray Cluster (Head node + Worker nodes) Serving: Ray Serve wrapping a FastAPI application Model Engine: vLLM for high-throughput inference ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:1:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"Why Ray Serve? Ray Serve excels at “model composition” and scaling. Unlike simple Docker containers, Ray allows us to: Scale independently: Scale the model replicas separately from the API handling logic. Batching: Native support for dynamic request batching to maximize GPU utilization. Pipeline composition: Easily chain multiple models or pre/post-processing steps. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:1:1","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"Configuration Here is a simplified serve_config.yaml to get started. This configuration defines a deployment that autoscales based on request load. proxy_location: EveryNode http_options: host: 0.0.0.0 port: 8000 applications: - name: llm_app route_prefix: / import_path: app:deployment runtime_env: pip: - vllm - fastapi deployments: - name: VLLMDeployment autoscaling_config: min_replicas: 1 max_replicas: 4 target_num_ongoing_requests_per_replica: 10 ray_actor_options: num_gpus: 1 ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:2:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"The FastAPI Wrapper We wrap the vLLM engine in a FastAPI app to expose standard REST endpoints. This allows easy integration with existing frontend applications or services. from fastapi import FastAPI from ray import serve from vllm import AsyncLLMEngine, SamplingParams app = FastAPI() @serve.deployment(num_gpus=1) @serve.ingress(app) class VLLMDeployment: def __init__(self): # Initialize vLLM engine self.engine = AsyncLLMEngine.from_engine_args(...) @app.post(\"/generate\") async def generate(self, prompt: str): sampling_params = SamplingParams(temperature=0.7, max_tokens=100) results = await self.engine.generate(prompt, sampling_params, ...) return {\"text\": results[0].outputs[0].text} deployment = VLLMDeployment.bind() ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:3:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"Deployment on AWS Cluster Setup: Use the Ray Cluster Launcher to provision EC2 instances. Define your cluster configuration in a cluster.yaml file, specifying the instance types (e.g., g5.xlarge for workers). Deploy: Run ray up cluster.yaml to start the cluster. Serve: Submit your serve application using serve run serve_config.yaml. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:4:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"Monitoring and Optimization Ray provides a built-in dashboard to monitor actor status, GPU usage, and request latency. For production, integrate this with Prometheus and Grafana to track: Queue Latency: Time requests spend waiting for a replica. GPU Utilization: Ensure you aren’t under-provisioning expensive hardware. Token Throughput: Measure tokens/second to benchmark performance. By leveraging Ray Serve with AWS, we create a flexible, scalable inference platform that avoids the vendor lock-in of managed services while providing full control over the serving infrastructure. ","date":"2025-11-22","objectID":"/blog/deploying-llms-aws-ray-serve/:5:0","tags":["devops"],"title":"Scalable LLM Deployment on AWS with Ray Serve and FastAPI","uri":"/blog/deploying-llms-aws-ray-serve/"},{"categories":null,"content":"Notes ","date":"2024-11-26","objectID":"/logs/2024/11/2025-11-26/:1:0","tags":["logs/2024-11"],"title":"November 26, 2024 — [NONE] Not Much Today ","uri":"/logs/2024/11/2025-11-26/"},{"categories":null,"content":"Logs log:: 22:00 Watched [[MOVIE\\Interstellar]] again. ","date":"2024-11-26","objectID":"/logs/2024/11/2025-11-26/:1:1","tags":["logs/2024-11"],"title":"November 26, 2024 — [NONE] Not Much Today ","uri":"/logs/2024/11/2025-11-26/"},{"categories":null,"content":"Tasks Finish AI Pathfinding ","date":"2024-11-26","objectID":"/logs/2024/11/2025-11-26/:1:2","tags":["logs/2024-11"],"title":"November 26, 2024 — [NONE] Not Much Today ","uri":"/logs/2024/11/2025-11-26/"}]