[{"categories":null,"content":"Notes ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:0","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Godot Signals Signals are Godot’s implementation of the observer pattern Use signal signal_name(param1, param2) to declare Emit with emit_signal(\"signal_name\", arg1, arg2) Connect with object.connect(\"signal_name\", self, \"_on_signal_received\") Super useful for decoupling game systems (e.g., player health changes triggering UI updates) ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:1","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"A* Pathfinding Started implementing A* for enemy AI Key insight: the heuristic function matters a lot for performance Using Manhattan distance for grid-based movement (no diagonals) Need to cache paths and only recalculate when player moves significantly Found a great visualization tool: pathfinding.js ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:2","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Go Interfaces Interfaces in Go are implicit - no need to declare implementation Any type that implements all methods automatically satisfies the interface Keep interfaces small (often just 1-2 methods) “Accept interfaces, return structs” is a common pattern The empty interface interface{} accepts any type (like any in newer Go versions) ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:3","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Random Discovered itch.io’s devlog feature - might cross-post there Need to set up a better note-taking workflow (currently using Obsidian + manual Hugo conversion) Read an interesting article about roguelike design patterns ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:4","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":null,"content":"Tomorrow Implement basic A* pathfinding for enemies Refactor player movement to use signals Write up a proper blog post about dungeon generation ","date":"2025-11-22","objectID":"/logs/2025-11-22-daily-notes/:1:5","tags":["learning-log","godot","algorithms"],"title":"Daily Logs - November 22, 2025","uri":"/logs/2025-11-22-daily-notes/"},{"categories":["Game Development"],"content":"Context I’ve been wanting to build a complete game from scratch for a while now. After exploring different genres, I settled on a roguelike because: Procedural generation is fascinating to me The scope is manageable for a solo dev There’s a great community and lots of resources I’m using Godot 4.2 because it’s lightweight, open-source, and has excellent 2D support. ","date":"2025-11-20","objectID":"/blog/first-devlog/:1:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"What I did This week I focused on getting the basic foundation in place: Set up the Godot project structure Implemented a simple grid-based movement system Created a basic dungeon generator using BSP (Binary Space Partitioning) Added collision detection for walls and obstacles Set up a camera that follows the player The dungeon generator was the most challenging part. I followed a tutorial initially but had to adapt it significantly to work with Godot 4’s new architecture. ","date":"2025-11-20","objectID":"/blog/first-devlog/:2:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"What I learned Godot’s tilemap system is powerful but has a learning curve. I spent a few hours debugging why my collisions weren’t working, only to realize I hadn’t set up the physics layers correctly. Procedural generation requires careful seeding. I want players to be able to share seeds for interesting dungeons, so I had to ensure my random number generation was deterministic. Start simple, iterate often. My first dungeon generator created boring rectangular rooms. Instead of trying to make it perfect immediately, I got something working and then improved it incrementally. ","date":"2025-11-20","objectID":"/blog/first-devlog/:3:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":["Game Development"],"content":"Next steps Add basic combat mechanics (attack, health, damage) Implement enemy AI (simple chase behavior) Create an inventory system Add item pickups (health potions, weapons) Design a few enemy types with different behaviors I’m aiming to have a playable prototype with combat by the end of next week. Follow along for more updates! ","date":"2025-11-20","objectID":"/blog/first-devlog/:4:0","tags":["gamedev","devlog","roguelike"],"title":"First Devlog: Starting My Roguelike Journey","uri":"/blog/first-devlog/"},{"categories":null,"content":"Problem I wanted to create a complete game from start to finish, something that would challenge me to learn game development fundamentals while being achievable as a solo developer. Roguelikes are perfect for this because: Procedural generation reduces the need for hand-crafted content Turn-based mechanics are easier to implement than real-time action The genre has well-established patterns and conventions There’s a passionate community that provides great feedback ","date":"2025-11-15","objectID":"/projects/sample-game/:1:0","tags":["gamedev","roguelike","2d"],"title":"Dungeon Crawler: Roguelike Adventure","uri":"/projects/sample-game/"},{"categories":null,"content":"Solution A classic roguelike dungeon crawler with: Procedural dungeon generation using BSP (Binary Space Partitioning) Turn-based combat with a variety of enemies and abilities Permadeath with meta-progression through unlockable characters Item system with weapons, armor, and consumables Pixel art aesthetic that’s achievable for a solo dev The game is designed to be playable in 15-30 minute runs, perfect for quick sessions. ","date":"2025-11-15","objectID":"/projects/sample-game/:2:0","tags":["gamedev","roguelike","2d"],"title":"Dungeon Crawler: Roguelike Adventure","uri":"/projects/sample-game/"},{"categories":null,"content":"Architecture / Stack Engine: Godot 4.2 Chose Godot for its excellent 2D support and open-source nature Using GDScript for rapid prototyping (may port to C# later for performance) Art: Aseprite All sprites created in Aseprite 16x16 pixel art style with a limited color palette Tools: Git for version control Trello for task management Obsidian for design documentation Key Systems: Dungeon Generator: BSP algorithm with room connections via corridors Combat System: Turn-based with action queue Entity Component System: Using Godot nodes as entities with component scripts Save System: JSON-based save files with run seeding for reproducibility ","date":"2025-11-15","objectID":"/projects/sample-game/:3:0","tags":["gamedev","roguelike","2d"],"title":"Dungeon Crawler: Roguelike Adventure","uri":"/projects/sample-game/"},{"categories":null,"content":"What I learned Procedural generation is harder than it looks. My first attempts created technically valid dungeons that were boring to play. I had to add constraints like minimum room sizes, maximum corridor lengths, and guaranteed item placement. Godot’s scene system is powerful. Using scenes as prefabs for enemies, items, and rooms made iteration much faster. I can test individual components in isolation. Playtesting early and often is crucial. I wasted time polishing systems that weren’t fun. Now I prototype mechanics quickly and test them before investing in polish. Scope creep is real. I had to cut several features (crafting system, multiple floors, boss fights) to focus on the core loop. I’m adding them back incrementally. ","date":"2025-11-15","objectID":"/projects/sample-game/:4:0","tags":["gamedev","roguelike","2d"],"title":"Dungeon Crawler: Roguelike Adventure","uri":"/projects/sample-game/"},{"categories":null,"content":"Screenshots or Demo Play the latest build on itch.io View source on GitHub Status: In active development. Currently implementing enemy AI and item system. Next milestones: Complete enemy AI with different behavior patterns Add 10+ unique items Implement meta-progression system Polish UI and add sound effects ","date":"2025-11-15","objectID":"/projects/sample-game/:5:0","tags":["gamedev","roguelike","2d"],"title":"Dungeon Crawler: Roguelike Adventure","uri":"/projects/sample-game/"},{"categories":null,"content":"Problem I was maintaining devlogs for multiple projects and found myself: Manually creating markdown files with the same front matter structure Forgetting to update project status and metadata Struggling to keep a consistent format across different projects Wasting time on boilerplate instead of writing actual content Existing tools like Hugo archetypes helped, but I wanted something more specialized for devlogs with features like: Automatic date/time stamping Project-specific templates Quick commands to list recent logs Integration with my Hugo-based site ","date":"2025-10-05","objectID":"/projects/sample-tool/:1:0","tags":["cli","productivity","tooling"],"title":"DevLog CLI: Static Site Generator for Devlogs","uri":"/projects/sample-tool/"},{"categories":null,"content":"Solution A lightweight CLI tool written in Go that: Generates devlog entries with consistent front matter and structure Manages multiple projects with project-specific configurations Provides quick commands to list, search, and open recent logs Integrates with Hugo by generating files in the correct content structure Supports templates for different log types (daily notes, project updates, etc.) Example usage: # Create a new devlog entry devlog new \"Implemented enemy AI\" # List recent logs devlog list --project roguelike --limit 5 # Open today's daily note devlog daily\r","date":"2025-10-05","objectID":"/projects/sample-tool/:2:0","tags":["cli","productivity","tooling"],"title":"DevLog CLI: Static Site Generator for Devlogs","uri":"/projects/sample-tool/"},{"categories":null,"content":"Architecture / Stack Language: Go 1.21 Fast compilation and execution Excellent standard library for file operations Easy cross-platform distribution (single binary) Libraries: cobra for CLI framework viper for configuration management goldmark for markdown parsing (for search features) Configuration: YAML config file (~/.devlog/config.yaml) Per-project settings in .devlog.yaml in project root Supports custom templates and front matter fields Key Features: Template engine for customizable log formats Front matter validation Fuzzy search through existing logs Git integration (auto-commit option) Hugo server integration (auto-reload) ","date":"2025-10-05","objectID":"/projects/sample-tool/:3:0","tags":["cli","productivity","tooling"],"title":"DevLog CLI: Static Site Generator for Devlogs","uri":"/projects/sample-tool/"},{"categories":null,"content":"What I learned Go is perfect for CLI tools. The standard library has everything you need, and distributing a single binary is so much easier than dealing with dependencies in Python or Node. Cobra makes CLI development pleasant. The command structure, flag parsing, and help generation are all handled elegantly. Configuration is harder than it seems. I went through several iterations of the config format before settling on a balance between flexibility and simplicity. Dogfooding is valuable. I used this tool daily while building it, which led to many UX improvements I wouldn’t have thought of otherwise. Documentation matters. I spent almost as much time on the README and examples as I did on the code. It paid off when others started using it. ","date":"2025-10-05","objectID":"/projects/sample-tool/:4:0","tags":["cli","productivity","tooling"],"title":"DevLog CLI: Static Site Generator for Devlogs","uri":"/projects/sample-tool/"},{"categories":null,"content":"Screenshots or Demo $ devlog new \"Added pathfinding system\" ✓ Created new devlog entry: content/blog/2025-11-22-pathfinding.md ✓ Opened in $EDITOR $ devlog list --limit 3 Recent devlogs: 2025-11-22 Added pathfinding system 2025-11-20 Implemented combat mechanics 2025-11-18 Dungeon generation refactor $ devlog daily ✓ Created daily note: content/notes/2025-11-22-daily-notes.md\rView source and documentation on GitHub Installation: go install github.com/yourusername/devlog-cli@latest\rStatus: Completed and actively maintained. Open to feature requests and contributions. Future ideas: Web UI for browsing logs Integration with other static site generators (Jekyll, 11ty) Export to different formats (PDF, EPUB) Analytics (word count, posting frequency, etc.) ","date":"2025-10-05","objectID":"/projects/sample-tool/:5:0","tags":["cli","productivity","tooling"],"title":"DevLog CLI: Static Site Generator for Devlogs","uri":"/projects/sample-tool/"}]